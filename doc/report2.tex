\chapter{Проектирование задачи}

В данном разделе описывается алгоритм вычисления хеша радиального отклонения,
структура программы и выбор инструментов разработки.

\section{Алгоритм решения задачи}

\subsection{Масштабирование изображения}
Масштабирование -- опциональный шаг, призванный повысить скорость обработки
изображения за счет уменьшения его размеров.

\subsubsection{Коэффициенты масштабирования}
Далее вычисляются коэффициенты масштабирования для осей X и Y путем деления
новых размеров на соответствующие старые.

\subsubsection{Создание нового изображения}
Создается новое изображение с заданными целевыми размерами. Обычно, это квадрат
с длиной стороны 8, 16, 32, 64 или 128.

\subsubsection{Интерполяция}
Проводится интерполяция значений цвета для каждого пикселя нового изображения на
основе значений цвета пикселей исходного. Для хеша не существенно качество
результата проведенной интерполяции, поэтому используется самая быстрая
интерполяция -- ближайший сосед. При этом методе каждому пикселю нового
изображения присваивается значение цвета ближайшего пикселя исходного
изображения.

\subsection{Обесцвечивание}
Для каждого пикселя уменьшенного изображения вычисляется среднее значение
цветовых каналов и присваивается пикселю в новом изображении, созданном заранее
в размерах, равных размеру уменьшенного изображения с целью уменьшения
информационной нагрузки изображения.

\subsection{Размытие Гаусса}
Размытие Гаусса -- последний шаг предобработки изображения, проводимый, чтобы
уменьшить влияние шумов на результат вычисления хеша. Можно подразделить на
две стадии: создание ядра Гаусса и фильтрацию.

\subsubsection{Создание ядра Гаусса}

Ядро Гаусса представляет собой матрицу чисел с плавающей точкой размером,
вычисляемым на основании сигмы, обычно -- умножение на шесть с округлением.
Размер обязательно должен быть нечетным. Значения вычисляются по формуле:

\[\begin{array}{c}
            \exp{(-\frac{x^2 + y^2}{2\sigma^2})}\div(2\pi\sigma^2). \\
      \end{array}\]\\
\begin{tabular}{r c l}
      где $x$, $y$ & -- & Расстояние до центра по оси $Ox$ ($Oy$); \\
      \(\sigma\)   & -- & стандартное отклонение.                  \\
\end{tabular}

\subsubsection{Фильтрация}

На этом этапе проводится итерация по полученному ядру свертки, в ходе которой
каждому пикселю изображения сопоставляется пиксель ядра, совмещая центры ядра и
изображения.

\subsection{Разделение изображения на сектора}

Для разбиения изображения на заданное количество секторов вычисляется градусная
мера угла между линией, соединяющей текущий пиксель с центром изображения и
горизонталью в диапазоне от 0 до 360 градусов включительно. Полученное значение
получает индекс посредством деления угла на размер сектора.

\subsection{Вычисление медиан и стандартных отклонений}

Далее вычисляется медиана и стандартное отклонение яркости каждого сектора. Для
стандартного отклонения берется корень от разности среднего во второй степени и
частного суммы квадратов разностей значений и среднего от деления на число
секторов.

\subsection{Составление хеша}

На основе вычисленных медиан и стандартных отклонений секторов изображения
формируется хеш, который представляет собой битовую последовательность: если
разница между медианами или стандартными отклонениями превышает порог,
устанавливаем соответствующий бит в хеше.

\subsection{Сравнение хешей}

Для сравнения изображений использован пиковый коэффициент корреляции, который,
пока константы находятся в разумных пределах, равнозначен процентному шансу
совпадения. Вычисляется по следующей формуле:

\[\begin{array}{c}
            \frac{n\cdot{}s-l\cdot{}r}{\sqrt{l(s-l)\cdot{}r(s-r)}} \\
      \end{array}\]\\
\begin{tabular}{r c l}
      где $l$, $r$ & -- & Количества единиц в хешах;                \\
      $s$          & -- & Количество совпавших единиц между хешами. \\
\end{tabular}

\section{Логическое моделирование}

\subsection*{Модуль приложения}

Отвечает за инициализацию программы и собирает воедино всю его бизнес"=логику.
Зона ответственности:

\begin{itemize}
      \item Обработка опций командной строки;
      \item Запуск и роль посредника для графического интефейса;
      \item Установка стартовых параметров;
      \item Отображение результатов;
      \item Изменение настроек программы;
      \item Обработка исключений;
      \item Загрузка кеша;
      \item Вызов модулей изменения состояния.
\end{itemize}

\subsection*{Модуль хеширования}

Отвечает за подсчет хешей изображений и их сравнение. Алгоритмическая структура
модуля была полностью рассмотрена в подразделе \ref{sec:2.1}. Необходимо и
достаточно реализовать реализовать по одной функции для каждого пункта и
подпункта подраздела.

\subsection*{Модуль итерации}

Модуль, посвященный вопросам обхода файловой системы для составления
списка изображений и последующей итерации с целью получения хешей или приведения
списка к нужному формату или иной обработки. Зона ответственности:

\begin{itemize}
      \item Проверка файла на возможность хеширования;
      \item Итарация по файлам и каталогам для составления списка изображений;
      \item Преобразование списка в таблицу хешей;
      \item Контроль настроек хеширования;
\end{itemize}

\subsection*{Модуль действий}

Отвечает за преобразования и вычисления на основе полученного списка:
форматирование и экспорт, дедубликация, кеширование.

\section{Выбор и обоснование инструментов разработки}

\subsection{Язык программирования}

Сравнение изображений, как и любая операция над медиа"=данными, требует много
вычислений, что делает краеугольным вопрос оптимизации и производительности.
\textit{C++} заслуженно считается лидером по производительности, обычно
превосходя \textit{Rust} и не конкурируя с \textit{C}, будучи с ним совместимым
\cite{benchmarksgame}. \textit{Rust} более современный язык, стремящийся его
заменить, проигрывает в силу меньшей востребованности, из"=за чего, раз курсовая
работа выполняется в учебных целях, изучение \textit{C++} приоритетнее, а
\textit{C} и так его подмножество.

\subsection{Фреймворк}

Курсовая работа требует изучать новые технологии на ходу, из"=за чего, когда
зашла речь о выборе графического фреймворка \textit{GTK} был предпочтен более
сложному \textit{Qt}, реализующему свою вариацию \textit{STL}. В плане простоты
выигрывают \textit{WinForms} и \textit{wxWidgets}, однако, первый эксклюзивен
для \textit{Windows}"=систем, а второй, как и в случае с выбора языка,
проигрывает в популярности.

\subsection{Библиотеки}

Для работы с изображениями было решено использовать \textit{PixBuf} --
простую библиотеку для работы с изображениями. Функционал очень скуден:
масштабирование изображения -- максимум возможностей и ряд поддерживаемых
форматов мал, но она она интегрирована в \textit{GTK} и является его
неотъемлемой частью.

Аналогично можно сказать и о \textit{GLib Testing Framework} -- не далеко
ушедшему от стандартной библиотеки фреймворку тестирования. Но иных решений с
для тестирования \textit{GTK} нет. Можно использовать и не специфичные решения,
но тут необходимости в них нет.

В 2021 году, из"=за слишком сильной привязанности \textit{GTK} к \textit{GNOME},
было решено вынести ряд стандартных окон и форм в отдельную библиотеку,
названную \textit{Adwaita}, а в зависимости от того, используется ли она,
называться программы на \textit{GTK} \textit{GNOME}"= и
\textit{GTK}"=приложениями соответственно. В силу эстетической притягательности
форм, библиотека была подключена.

\subsection{Система сборки}

Для сборки проекта была использована комбинация \textit{Meson} и \textit{Nix}.
Первый -- рекомендованная разработчиками \textit{GTK} и \textit{GNOME}
современная декларативная система сборки, лучше адаптированная к \textit{GTK},
чем \textit{CMake} и в разы превосходящая слишком сложный, но малофункциональный
\textit{Autoconf}. Для установки зависимостей был использован \textit{nix},
пакетный менеджер с удобной функцией рабочих окружений в каталогах и
\textit{direnv} для их автоматической загрузки. Выбран, так как прост в
использовании, не засоряет систему дубликатами библиотек и не требует
дополнительной настройки для встраивания в цикл сборки, в отличии от
\textit{vcpkg}.

Для компиляции проекта использовался \textit{clang}, по причине того, что при
разработке использовались \textit{clangd} и \textit{clang-uml}, которые от него
зависят, тестирование проводилось на процессоре \textit{AMD}, из"=за чего от
выбора \textit{ICC} бы не было бы какого"=либо преимущества, а причин выбрать
его прямого конкурента, \textit{GCC}, кроме репутации последнего, не имелось.

\subsection{Рабочая среда}

Для разработки программы был выбран редактор \textit{Visual Studio Code} по
следующим причинам:

\begin{itemize}
      \item Большой опыт его применения;
      \item Поддержка всех вышеназванных технологий через расширения, такие как
            \textit{clangd}, \textit{direnv}, \textit{Meson};
      \item За счет расширений формируется среда не только разработки программы,
            но и верстки пояснительной записки. Ключевая причина, так как
            воссоздать ее в другом \textit{IDE} будет тяжело.
\end{itemize}

\subsection{Разработка интерфейса}

В экосистеме \textit{GTK4} существует несколько способов разработки графического
интерфейса: программирование вручную, использование \textit{XML}"=описания,
\textit{blueprint}"=файлов или \textit{RAD}. Большинство разработчиков
предпочитают избегать описания интерфейса непосредственно в коде, так как это
приводит к избыточности и усложняет понимание программы. Использование
Декларативных \textit{XML} и \textit{blueprint}, также имеют свои недостатки, в
частности, громоздкость и проблемы с поддержкой некоторых функций
соответственно.

По"=этому, для проектирования пользовательского интерфейса был выбран
\textit{Cambalache} -- \textit{RAD}"=среда, пришедшая на смену устаревшему
\textit{Glade} и поддерживающая \textit{GTK4}.

\vspace{\baselineskip}
\phantomheading[section]{Заключение}

В разделе был проведен подробный разбор алгоритма хеширования,
проиллюстрированный схемой в приложении \ref{sec:Б}, проведена оценка
необходимых модулей и сформированы трабования к ним,а также были определены
средства разработки в соответветствии с требованиями к ним.
