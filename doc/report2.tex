\chapter{Проектирование задачи}

В данном разделе описывается алгоритм вычисления хеша радиального отклонения,
структура программы и выбор инструментов разработки.

\section{Алгоритм решения задачи}

\subsection{Масштабирование изображения}
Масштабирование -- опциональный шаг, призванный повысить скорость обработки
изображения за счет уменьшения его размеров.

\subsubsection{Коэффициенты масштабирования}
Далее вычисляются коэффициенты масштабирования для осей X и Y путем деления
новых размеров на соответствующие старые.

\subsubsection{Создание нового изображения}
Создается новое изображение с заданными целевыми размерами. Обычно, это квадрат
с длиной стороны 8, 16, 32, 64 или 128.

\subsubsection{Интерполяция}
Проводится интерполяция значений цвета для каждого пикселя нового изображения на
основе значений цвета пикселей исходного. Для хеша не существенно качество
результата проведенной интерполяции, поэтому используется самая быстрая
интерполяция -- ближайший сосед. При этом методе каждому пикселю нового
изображения присваивается значение цвета ближайшего пикселя исходного
изображения.

\subsection{Обесцвечивание}
Для каждого пикселя уменьшенного изображения вычисляется среднее значение
цветовых каналов и присваивается пикселю в новом изображении, созданном заранее
в размерах, равных размеру уменьшенного изображения с целью уменьшения
информационной нагрузки изображения.

\subsection{Размытие Гаусса}
Размытие Гаусса -- последний шаг предобработки изображения, проводимый, чтобы
уменьшить влияние шумов на результат вычисления хеша. Можно подразделить на
две стадии: создание ядра Гаусса и фильтрацию.

\subsubsection{Создание ядра Гаусса}

Ядро Гаусса представляет собой матрицу чисел размером  с плавающей точкой,
которые вычисляются по данной формуле: риориоиоь ь ьииормомпомпрмпрмрмрс

% \[\begin{array}{c}
%             x=i-\frac{s}{2},\label{eq:x} \\
%             y=j-\frac{s}{2},\label{eq:y} \\
%             \dfrac{e^{-\frac{x^2 + y^2}{2\sigma^2}}}{2\pi\sigma^2}.\label{eq:kernel}
%       \end{array}\]\\
% \begin{tabular}{r c l}
%       где $x$, $y$ & -- & Расстояние до центра по оси $Ox$ ($Oy$); \\
%       $i$, $j$     & -- & Текущее положение по оси $Oy$; ($Oy$);   \\
%       $s$          & -- & Длина стороны изображения;               \\
%       \(\sigma\)   & -- & стандартное отклонение.                  \\
% \end{tabular}

% Ядро Гаусса создается с заданным размером и стандартным отклонением с помощью
% метода get_gaussian_kernel.

\subsubsection{Фильтрация}

% Применяется фильтрация изображения с использованием созданного ядра Гаусса.

\subsection*{Разделение изображения на сектора}

% Изображение разделяется на несколько секторов с равным угловым шагом. Для
% каждого пикселя изображения определяется его сектор на основе угла, который он
% образует с центром изображения. Это позволяет учесть структурные особенности
% изображения.

\subsection*{Вычисление медиан и стандартных отклонений}

% Для каждого сектора изображения вычисляются медианы и стандартные отклонения
% яркости пикселей.

\subsection*{Составление хеша}

% На основе вычисленных медиан и стандартных отклонений секторов изображения
% формируется хеш, который представляет собой битовую последовательность,
% отражающую структурные особенности изображения.

% Вычисленный хеш преобразуется в целочисленное значение с помощью хеш-функции.

\subsection*{Сравнение хешей}

% Для сравнения двух хешей используется метрика сходства, основанная на сравнении
% значений хешей. Чем меньше различий между хешами, тем более похожи изображения.



\section{Логическое моделирование}
% 2.2 Описание модулей программы, каждый модуль описывается как самостоятельная
% единица, которая выполняет определённый набор функций в программе, нет
% ситуаций, когда модуль есть, чтобы есть. (Диаграмма классов)

\subsection{Файловый модуль}

Модуль, отвечающий за все взаимодействия с файловой системой

\subsection{Графический модуль}

\subsection{Модуль действий}



\section{Выбор и обоснование инструментов разработки}

\subsection{Язык программирования}
Сравнение изображений, как и любая операция над медиа"=данными, требует много
вычислений, что делает краеугольным вопрос оптимизации и производительности.
\textit{C++} заслуженно считается лидером по производительности, обычно
превосходя \textit{Rust} и не конкурируя с \textit{C}, будучи с ним совместимым
\cite{benchmarksgame}. \textit{Rust} более современный язык, стремящийся его
заменить, проигрывает в силу меньшей востребованности, из"=за чего, раз курсовая
работа выполняется в учебных целях, изучение \textit{C++} приоритетнее, а
\textit{C} и так его подмножество.

\subsection{Фреймворк}
Курсовая работа требует изучать новые технологии на ходу, из"=за чего, когда
зашла речь о выборе графического фреймворка \textit{GTK} был предпочтен более
сложному \textit{Qt}, реализующему свою вариацию \textit{STL}. В плане простоты
выигрывают \textit{WinForms} и \textit{wxWidgets}, однако, первый эксклюзивен
для \textit{Windows}"=систем, а второй, как и в случае с выбора языка,
проигрывает в популярности.

\subsection{Библиотеки}
В 2021 году, из"=за слишком сильной привязанности \textit{GTK} к \textit{GNOME},
было решено вынести ряд стандартных окон и форм в отдельную библиотеку,
названную \textit{Adwaita}, а в зависимости от того, используется ли она,
называться программы на \textit{GTK} \textit{GNOME}"= и
\textit{GTK}"=приложениями соответственно. В силу эстетической притягательности
форм, библиотека была подключена.

\subsection{Система сборки}
Для сборки проекта была использована комбинация \textit{Meson} и \textit{Nix}.
Первый -- рекомендованная разработчиками \textit{GTK} и \textit{GNOME}
современная декларативная система сборки, лучше адаптированная к \textit{GTK},
чем \textit{CMake} и в разы превосходящая слишком сложный, но малофункциональный
\textit{Autoconf}. Для установки зависимостей был использован \textit{nix},
пакетный менеджер с удобной функцией рабочих окружений в каталогах и
\textit{direnv} для их автоматической загрузки. Выбран, так как прост в
использовании, не засоряет систему дубликатами библиотек и не требует
дополнительной настройки для встраивания в цикл сборки, в отличии от
\textit{vcpkg}.

Для компиляции проекта использовался \textit{clang}, по причине того, что при
разработке использовались \textit{clangd} и \textit{clang-uml}, которые от него
зависят, тестирование проводилось на процессоре \textit{AMD}, из"=за чего от
выбора \textit{ICC} бы не было бы какого"=либо преимущества, а причин выбрать
его прямого конкурента, \textit{GCC}, кроме репутации последнего, не имелось.

\subsection{Рабочая среда}
Для разработки программы был выбран редактор \textit{Visual Studio Code} по
следующим причинам:

\begin{itemize}
      \item Большой опыт его применения;
      \item Поддержка всех вышеназванных технологий через расширения, такие как
            \textit{clangd}, \textit{direnv}, \textit{Meson};
      \item За счет расширений формируется среда не только разработки программы,
            но и верстки пояснительной записки. Ключевая причина, так как
            воссоздать ее в другом \textit{IDE} будет тяжело.
\end{itemize}

В экосистеме \textit{GTK4} существует несколько способов разработки графического
интерфейса: программирование вручную, использование \textit{XML}"=описания,
\textit{blueprint}"=файлов или \textit{RAD}. Большинство разработчиков
предпочитают избегать описания интерфейса непосредственно в коде, так как это
приводит к избыточности и усложняет понимание программы. Использование
Декларативных \textit{XML} и \textit{blueprint}, также имеют свои недостатки, в
частности, громоздкость и проблемы с поддержкой некоторых функций
соответственно.

По"=этому, для проектирования пользовательского интерфейса был выбран
\textit{Cambalache} -- \textit{RAD}"=среда, пришедшая на смену устаревшему
\textit{Glade} и поддерживающая \textit{GTK4}.
