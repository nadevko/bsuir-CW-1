\chapter{Проектирование задачи}

\section{Алгоритм решения задачи}
% 2.1 Описываете способы решения задач, которые есть в приложении. Шифрование
% паролей, хранение информации, сортировка пользователей, создание интерфейса
% пользователя, описание проблем когерентности данных в файлах и способы их
% решения.

\subsection{Масштабирование изображения}
Сравнения изображений посредством перцептивного хеширования можно разделить на
три этапа: масштабирование изображений, вычисление хешей и их сравнение. Для
масштабирования изображения выбран алгоритм билинейной интерполяции, так как он
прост и эффективен. Он работает следующим образом: для каждого пикселя в новом
изображении находится ближайший пиксель в исходном изображении, а затем
вычисляется среднее значение цвета пикселей вокруг него. Этот метод обеспечивает
хорошее качество изображения при увеличении или уменьшении его размера.

\subsection{Вычисление хеша}
Перцептивное хеширование -- трехэтапный процесс

\subsection{Сравнение хешей}

\subsection{Обход коллекции}

\section{Логическое моделирование}
% 2.2 Описание модулей программы, каждый модуль описывается как самостоятельная
% единица, которая выполняет определённый набор функций в программе, нет
% ситуаций, когда модуль есть, чтобы есть. (Диаграмма классов)

\subsection{Модуль приложения}

\subsection{Модуль изображения}

\subsection{Модуль списка}

\section{Выбор и обоснование инструментов разработки}

\subsection{Язык программирования}
Сравнение изображений, как и любая операция над медиа"=данными, требует много
вычислений, что делает краеугольным вопрос оптимизации и производительности.
\textit{C++} заслуженно считается лидером по производительности, обычно
превосходя \textit{Rust} и не конкурируя с \textit{C}, будучи с ним совместимым
\cite{benchmarksgame}. \textit{Rust} более современный язык, стремящийся его
заменить, проигрывает в силу меньшей востребованности, из"=за чего, раз курсовая
работа выполняется в учебных целях, изучение \textit{C++} приоритетнее, а
\textit{C} и так его подмножество.

\subsection{Фреймворк}
Курсовая работа требует изучать новые технологии на ходу, из"=за чего, когда
зашла речь о выборе графического фреймворка \textit{GTK} был предпочтен более
сложному \textit{Qt}, реализующему свою вариацию \textit{STL}. В плане простоты
выигрывают \textit{WinForms} и \textit{wxWidgets}, однако, первый эксклюзивен
для \textit{Windows}"=систем, а второй, как и в случае с выбора языка,
проигрывает в популярности.

\subsection{Библиотеки}
В 2021 году, из"=за слишком сильной привязанности \textit{GTK} к \textit{GNOME},
было решено вынести ряд стандартных окон и форм в отдельную библиотеку,
названную \textit{Adwaita}, а в зависимости от того, используется ли она,
называться программы на \textit{GTK} \textit{GNOME}"= и
\textit{GTK}"=приложениями соответственно. В силу эстетической притягательности
форм, библиотека была подключена.

Реализация чтения и записи сложных форматов изображений, подобных \textit{PNG},
\textit{WebP} или \textit{AVIF} достойны быть темой отдельной курсовой работы, а
простые, такие как \textit{BMP}, не применяются на практике и сделают программу
бесполезной для конечного пользователя. Следовательно, решено использовать
библиотеку для работы с изображениями. \textit{Magick++} поддерживает больше
типов файлов, однако, за более удобное представление изображения в процессе
работы, предпочтена \textit{OpenCV}.

\subsection{Система сборки}
Для сборки проекта была использована комбинация \textit{Meson} и \textit{Nix}.
Первый -- рекомендованная разработчиками \textit{GTK} и \textit{GNOME}
современная декларативная система сборки, лучше адаптированная к \textit{GTK},
чем \textit{CMake} и в разы превосходящая слишком сложный, но малофункциональный
\textit{Autoconf}. Для установки зависимостей был использован \textit{nix},
пакетный менеджер с удобной функцией рабочих окружений в каталогах и
\textit{direnv} для их автоматической загрузки. Выбран, так как прост в
использовании, не засоряет систему дубликатами библиотек и не требует
дополнительной настройки для встраивания в цикл сборки, в отличии от
\textit{vcpkg}.

Для компиляции проекта использовался \textit{clang}, так как при разработке
проекта использовались \textit{clangd} и \textit{clang-uml}, которые от него
зависят, тестирование проводилось на процессоре \textit{AMD}, из"=за чего от
выбора \textit{ICC} бы не было.

только с ним заработало автодополнение кода в
\textit{Visual Studio Code}, хотя, планировалось использовать \textit{clang},
ведь использовались, зависящие от него, .

\subsection{Рабочая среда}
Для разработки программы был выбран редактор \textit{Visual Studio Code} по
следующим причинам:

\begin{itemize}
    \item Большой опыт его применения;
    \item Поддержка всех вышеназванных технологий через расширения, такие как
          \textit{clangd}, \textit{direnv}, \textit{Meson};
    \item За счет расширений формируется среда не только разработки программы,
          но и верстки пояснительной записки. Ключевая причина, так как
          воссоздать ее в другом \textit{IDE} будет тяжело.
\end{itemize}

В экосистеме \textit{GTK4} существует несколько способов разработки графического
интерфейса: программирование вручную, использование \textit{XML}"=описания,
\textit{blueprint}"=файлов или \textit{RAD}. Большинство разработчиков
предпочитают избегать описания интерфейса непосредственно в коде, так как это
приводит к избыточности и усложняет понимание программы. Использование
Декларативных \textit{XML} и \textit{blueprint}, также имеют свои недостатки, в
частности, громоздкость и проблемы с поддержкой некоторых функций
соответственно.

По"=этому, для проектирования пользовательского интерфейса был выбран
\textit{Cambalache} -- \textit{RAD}"=среда, пришедшая на смену устаревшему
\textit{Glade} и поддерживающая \textit{GTK4}.
