\documentclass[variant=courcework]{bsuir}

\faculty{компьютерного проектирования}
\departmentlong{инженерной психологии и эргономики}
\departmentshort{эргономики}
\manager{эргономики}
\worktitle{Создание сервиса поиска визуально схожих изображений в
неорганизованных коллекциях}
\workcode{БГУИР КР 1-58 01 01 002 ПЗ}
\titleright{Студент\\Руководитель}
\titleleft{Бородин А.Н.\\Кабариха В.А.}
\titlepageyear{2024}

\begin{document}

\maketitle

\includepdf[pages=-]{task.pdf}

\tableofcontents

\chapter*{Введение}

Спрос на область больших данных в наше время растет с каждым днем, из-за чего
проблема дедубликации становится все более актуальной. В силу автоматизации и
безконтрольности процесса пополнения коллекции, задача минимизации данных
становится все серьезнее: чем больше система, тем выше необходимость в
задействовании систем сжатия, минимизации и дедубликации.

Дедубликация изображений -- процесс обнаружения и удаления дубликатов
изображений, на основе оценки визуальной схожести посредством метрик сходства,
индексации и хеширования признаков или применения алгоритмов глубокого обучения.
Это позволяет освободить ценное дисковое пространство и упростить управление
данными, не только в сфере больших данных по и в любых базах данных или
пользовательских коллекциях.

Одним из важных направлений является разработка алгоритмов, способных работать с
неорганизованными коллекциями, где отсутствует предварительная классификация или
метаданные. Использование методов нечеткого поиска и семантического анализа
позволяет выявлять схожие изображения на основе контента, даже если они не имеют
явных визуальных сходств.

Данная курсовая работа выполнена с целью исследования существующих методов
сравнения изображений, оценки вероятности их совпадения, выбора оптимального
алгоритма и его реализации для решения задачи дедубликации изображений в форме
программы с графическим интерфейсом, изучив для этого соответствующие
технологии.

В ходе написания курсовой работы так же были составлен анализ области сравнения
изображений, выполнен сравнительный анализ существующих решений, составлен
оптимальный набор инструментов, описана структура разработанной программы и ее
модулей, результаты тестирования и руководство использования.

Разработанная программа может помочь обычным пользователям в процессе
организации их персональных коллекций и разработчикам более крупных проектов При
разработке их программных продуктов.

\chapter{Постановка задачи}

\section{Описание предметной области}

Если для отдельного пользователя столкновение с пределом объема памяти
оборачивается простым поиском файлов к удалению, то для бизнеса это лишние
денежные траты на расширение своих хранилищ. Для откладывания неизбежного
истощения свободного места непрерывно разрабатываются новые методы сжатия,
минимизации и дедубликации информации.

Для нахождения дубликата, требуется оценить визуальное сходство. К сравнению
изображений есть три основных подхода: метрики, хеширование и машинное обучение.

Технологии машинного зрения наиболее защищены от всего спектра визуальных атак,
на подобии гауссовского шума или поворота изображения и способны оценить не
только визуальное сходство, но смысловое. Однако, они чрезмерно время- и
трудозатратны для массового применения.

Метрики же наоборот, высокоэкономичны, однако, уязвимы. К примеру, наиболее
популярная метрика, Индекс Структурного Сходства (SSIM), теряет смысл на
обрезанных и перевернутых изображениях. Для решения ее проблем было разработано
множество модификаций, но не одну нельзя назвать достаточно надежной: MS-SSIM,
3-SSIM, DSSIM, CW-SSIM, SSIMPLUS, cSSIM, SSIMULACRA, SSIMULACRA2, G-SSIM.
Однако, если точность не имеет особого значения, они очень полезны. Для
примитивных сравнений есть упрощенные оценки: пиковое отношение сигнала к шуму
(PSNR) и среднеквадратичная ошибка (MSE).

Оптимальным в этой ситуации оказывается хеширование. Все алгоритмы хеширования
схожи: уменьшение размера, преобразование цветов, преобразования матрицы и
сравнение с другим хешем. В случае самого известного, перцептивного хеша:
уменьшение до 64 пикселей, обесцвечивание, замена каждого элемента на результат
его сравнения со средним значением по матрице и сравнение хешей через поиск
расстояния Хэмминга. Также популярны: по среднему значению блока, по цветовым
моментам, по преобразованию Радона, по среднему, по Марру-Гилдрету.

\section{Сравнительный анализ}

\subsection*{\textquote{rmlint}}

На рисунке \ref{img:rmlint.png} приводится пример вывода \textquote{rmlint},
консольной программы для поиска дубликатов общего предназначения. Для сравнения
файлов используется хеш-функция blake2b. Дополнительные варианты: paranoid,
highway256, metro256, metro (в порядке возрастания точности). По окончанию
работы, программа генерирует скрипт для удаления, по умолчанию shell-скрипт,
найденных файлов и json-перечень найденного.

Работает быстро, программа удобна, не переусложнена лишним функционалом и имеет
много режимов работы и форматов вывода результата. Однако, она не способна
оценивать содержимое изображений и видео визуально и работать с метаданными, что
делает ее уязвимой к визуальным атакам, в том же числе, к одинаковым
изображениям, сохраненным в разных форматах.

\hyphenation{ус-ло-вий}

Наиболее уникальной особенностью можно назвать широкий выбор условий
автоматического выбора оставляемой копии из нескольких дубликатов и удаление не
только дублирующихся файлов, но и каталогов. Написан на C и Python.

Так же, ведется разработка графического интерфейса, совмещающего в себе режим
древовидного осмотра файловой системы с круговой диаграммой объемов файлов в
выбранном каталоге, очень похожий на программу анализа дискового пространства из
стандартного набора среды рабочего стола GNOME, режим составления списка
каталогов к анализу, текстовый редактор для результирующих sh, txt и csv файлов
и окно настроек, позволяющее настроить все аспекты программы. Написан gtk+ 3.

\makeimage[Вывод \texttt{rmlint -g}]{rmlint.png}

\subsection*{\textquote{imagededup}}

\textquote{imagededup} -- не программа, а библиотека на языке python. Она может
быть не только встроена в иную программу, но и применена в роли утилиты в
REPL-оболочке. Библиотека расчитана исключительно на работу с изображениями и,
помимо обычного решения задачи через хеширование, представленного в 4 вариантах,
поддерживает сравнение посредством сверточной нейросети. Всего, 5 методик
сравнение:

\begin{itemize}
    \item Сверточная нейронная сеть (CNN) -- используя одну из нескольких
          готовых моделей или свою собственную.
    \item Перцептивное хеширование (PHash)
    \item Хеширование разностей (DHash)
    \item Вейвлет-хеширование (WHash)
    \item Среднее хеширование (AHash)
\end{itemize}

Библиотека, в первую очередь, ориентированная на исследовательские нужды и
работу с нейросетями, к примеру, с использованием numpy и jupyter, от чего она
отличается возможностью генерирации совмещенных изображений, для иллюстрации
проведенного сравнения.

Для практического использования она имеет слишком высокий порог входа и мало
функционала: код изначальной и конечной выборки файлов и определения удаляемых
требуется писать самостоятельно, что требует знания языка python. На рисунке
\ref{img:imagededup.png} приведен пример состаления сравнительного изображения
для отдельного изображения со всеми в указанном каталоге.
\\

\makeimage[Пример применения \textquote{imagededup}]{imagededup.png}

\subsection*{\textquote{Czkawka}}

Изображенная на рисунке \ref{img:czkawka.png} \textquote{Czkawka} -- наследница
заброшенного с 2017 проекта FSlint. В отличии от оригинала на python 2 с gtk 2 и
работающего только под линукс-системами, разработан на rust с gtk 4
(альтернативный фронтенд -- slint) и кроссплатформенна. Программа обеспечивает
широкий спектр интрументов для поддержания порядка в файловой системе: помимо
дедубликации посредством универсального хеширования, имеются отдельные
обработчики фото, аудио и видео, поиск пустых и временных файлов и каталогов,
невалидных ссылок, имен, больших файлов. Для сравнение изображений используется
настраиваемый хеш:

\begin{itemize}
    \item Алгоритм изменения размера изображения: Lanczos3, Nearest, Triangle,
          Gaussian, CatmullRom;
    \item Размер хеша: 8, 16, 32, 64;
    \item Тип хеша: одинарный, вертикальный или двойной градиентный, блочный,
          средний.
\end{itemize}

\makeimage[Интерфейс Czkawka]{czkawka.png}

\section{Информационная база задачи}

Для программы дедубликации нет смысла в сохранении каких либо данных между
сеансами, будь то параметры программы или кеш, так как при каждом запуске
пользователю нужно иные параметры. Единственная информация, которую требуется
знать программе о файле, это ее хеш. Обычно именно хеш выступает в роли
идентификатора неизменности файла, однако, его возможно хранить

Обычно хеш выступает в роли идентификатора
информации,   что требуется знать о файле, но, обычно, именно хеш выступает в
роли идентификатора неизменности файла, из-за чего его регулярно пересчитывают.

\section{Функциональное назначение}

От программы требуется:

\begin{itemize}
    \item ручное и автоматическое добавление файлов;
    \item составление списка изображений, поддерживаемых хеш-функцией;
    \item вычисление перцептивных хешей изображений;
    \item сравнение вычисленных хешей;
    \item шаблонирование при задании новых имен и путей файлов в поиске;
    \item открытие изображений для просмотра;
    \item указание параметров их сравнения;
    \item генерация скриптов для удаления файлов;
    \item графический интерфейс.\\
\end{itemize}

В разделе была рассмотрена задача о дедубликации изображений, существующие
методы ее решения и программные решения, проведено сравнение, оценена
потребность в межсессионном хранении информации и составлен перечень требуемого
функционала. 

\chapter{Проектирование задачи}

\section{Алгоритм решения задачи}

Самый главный алгоритм программы, ради которого она разрабатывалась ---
сравнение изображений. Для этого мы будем использовать
алгоритм вычисления перцептивного хеша. 

\makesvg[Диаграмма активности]{activity}

\section{Логическое моделирование}

Для работы с дубликатами изображений наилучшим решением послужила программа,
напоминающая файловый менеджер: выводящая список, считанных при запуске файлов
текущего каталога, с возможностью его смены и просмотра файлов. Определение же
дубликатов можно рассматривать как фильтр, исключающий все изображения, имеющие
копию с большим или равным указанному значению процентом схожести. Также
желательны было реализовать фильтр по имени файла и сортировку списка по
наиболее важным параметрам при выборе копии, которая останется: местоположению,
дате создания и размеру. Обладая выборкой файлов было бы естественно пожелать
помимо возможности удалить ее, перенос, переименовывание или копирование.
Особенно хорошо смотрелась бы конвертация файла в иной формат, при смене
расширения и автоматическая очистка системы через автопоиск дубликатов и тихую
конвертацию файлов в менее объемные форматы.

В таком случае, каждую операцию над файлами и каждый фильтр можно реализовать
как класс, соответствующий общему интерфейсу операции или фильтра, с которым
работает класс списка, считывающий файлы каталога по данному ему пути и
модифицирующий булевую маску видимости элементов исходя из переданной ему
операции или же фильтра.

\makesvg[Диаграмма вариантов использования]{usecases}

\section{Выбор и обоснование инструментов разработки}

Для решения задачи был выбран язык C++, как изучаемый и гарантирующий хорошие
показатели производительности, а при работе с медиа это очень важный вопрос, и
GTK, один из самых популярных фреймворков для построения графического
интерфейса. Главным его конкурентом, обходящим по популярности, является Qt,
который ориентируется на C++, пока GTK разрабатывается с расчетом на C.
Контринтуитивно, однако был выбран GTK, ведь библиотеки на C проще адаптировать
к другим языкам, из-за чего GTK можно использовать с любым популярным, или не
очень, языком программирования, а так как разработчикам пришлость написать свою
ООП--систему, а не влиться в существующую парадигму, его проще изучить.

В мире GTK4 есть 4 способа разработки интерфейса: как код, XML, blueprint или в
RAD. Большинство разработчиков предпочитают избегать описания интерфейса в коде,
потому-что получается избыточно--многословно и усложняет понимания кода,
рассредотачивая внимания и лишает дизайнеров шанса понять, что же делают
разработчики. Для декларативного описания интерфейса используется местный
безымянный диалект XML, но это язык не менее громоздкий, от чего был разработан
blueprint-compiler, препроцессор, компилирующий QML--подобные blueprint--файлы в
XML. Формат еще молод и имеет много проблем, к примеру, нет поддержки значений
типа string[]. Следовательно, выбираем cambalache, RAD IDE, пришедшую на смену
Glade, не поддерживающего GTK4.

Для сборки проекта была использована комбинация meson и nix. Первый ---
рекомендованная разработчиками GTK и GNOME система сборки, чьи дочерним проектом
GTK и является, выгодно отличающаяся удобством использования и интеграцией с
IDE, которая заставила отвернуться от классического для C++--проектов CMake и,
тем более, свойственного малым Make. За счет интеграции, без проблем может быть
использована любая IDE с поддержкой meson, такие, как Visual Studio Code. Nix
же, как пакетный менеджер, отвечал за внешние зависимости проекта и
пакетирование программы для полноценной ее установки.

\chapter{Программная реализация}

\section{Физическая структура}

\subsection*{default.nix}

Nix--пакет программы.

\subsection{meson.build}

Точка входа в систему сборки.

\subsection{shell.nix}

Конфиг рабочего окружения.

\subsection{src/assets/logo/}

Каталог с вариантами логотипа в разных размерах.

\subsection{src/assets/meson.build}

Скрипт сборки ассетов.

\subsection{src/assets/template.desktop}

Шаблон desktop--файла.

\subsection{src/assets/template.desktop}

Шаблон desktop--файла.

\subsection{src/gresources.xml}

Индекс всех ресурсов программы.

\subsection{src/i18n}

Каталог с файлами gettext--переводов.

\subsection{src/main.cc}

Точка входа в программу.

\subsection{src/meson.build}

Скрипт сборки программы.

\subsection{src/views}

Каталог с конфигурациями интерфейса.

\section{Описание разработанных модулей}

\subsection{Взаимодействие классов}

\makesvg[Диаграмма классов]{classes}

\subsection{main.cc}

Инициализирует программу.

\chapter{Тестирование}

\chapter{Применение программы}

\section{Руководство пользователя}

\chapter*{Заключение}

\bibliography{lib}

\appendix

\chapter[обязательное]{Исходный код программы}

\makelisting{../src/application.cc}[src/application.cc]
\makelisting{../src/application.hh}[src/application.hh]
\makelisting{../src/gresources.xml}[src/gresources.xml]
\makelisting{../src/image.hh}[src/image.hh]
\makelisting{../src/list.hh}[src/list.hh]
\makelisting{../src/main.cc}[src/main.cc]
\makelisting{../src/main.hh}[src/main.hh]
\makelisting{../src/views/about.ui}[src/views/about.ui]
\makelisting{../src/views/application.ui}[src/views/application.ui]
\makelisting{../src/views/preferences.ui}[src/views/preferences.ui]

\end{document}
